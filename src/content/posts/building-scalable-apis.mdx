---
title: "Building Scalable REST APIs with Node.js"
date: "2024-11-22"
excerpt: "Learn best practices for designing and implementing scalable REST APIs using Node.js, Express, and modern architectural patterns."
author: "David Kumar"
coverImage: "/images/api-cover.jpg"
tags: ["Node.js", "API", "Backend", "REST"]
readTime: "12 min read"
---

# Building Scalable REST APIs with Node.js

In today's interconnected world, APIs are the backbone of modern applications. Building scalable REST APIs requires careful planning, proper architecture, and adherence to best practices.

## Understanding REST Principles

REST (Representational State Transfer) is an architectural style that defines constraints for creating web services:

- **Client-Server Architecture**: Separation of concerns
- **Statelessness**: Each request contains all necessary information
- **Cacheability**: Responses must define themselves as cacheable or not
- **Uniform Interface**: Consistent way to interact with resources
- **Layered System**: Architecture composed of hierarchical layers

## Setting Up Your Node.js API

Start with a solid foundation:

```javascript
// server.js
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import compression from 'compression';

const app = express();

// Security middleware
app.use(helmet());
app.use(cors());
app.use(compression());
app.use(express.json());

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
```

## API Design Best Practices

### 1. Use Proper HTTP Methods

- `GET`: Retrieve resources
- `POST`: Create new resources
- `PUT`: Update entire resources
- `PATCH`: Partial updates
- `DELETE`: Remove resources

### 2. Version Your API

```javascript
// Version in URL
app.use('/api/v1', v1Routes);
app.use('/api/v2', v2Routes);

// Version in header
app.use((req, res, next) => {
  const version = req.headers['api-version'] || 'v1';
  req.apiVersion = version;
  next();
});
```

### 3. Implement Proper Status Codes

```javascript
// Success responses
res.status(200).json({ data }); // OK
res.status(201).json({ data }); // Created
res.status(204).send(); // No Content

// Client errors
res.status(400).json({ error: 'Bad Request' });
res.status(401).json({ error: 'Unauthorized' });
res.status(404).json({ error: 'Not Found' });

// Server errors
res.status(500).json({ error: 'Internal Server Error' });
```

## Scalability Patterns

### 1. Database Connection Pooling

```javascript
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});
```

### 2. Caching Strategy

```javascript
import Redis from 'ioredis';

const redis = new Redis();

const cacheMiddleware = (duration) => {
  return async (req, res, next) => {
    const key = `cache:${req.originalUrl}`;
    const cached = await redis.get(key);
    
    if (cached) {
      return res.json(JSON.parse(cached));
    }
    
    res.sendResponse = res.json;
    res.json = (body) => {
      redis.set(key, JSON.stringify(body), 'EX', duration);
      res.sendResponse(body);
    };
    
    next();
  };
};
```

### 3. Rate Limiting

```javascript
import rateLimit from 'express-rate-limit';

const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP'
});

app.use('/api/', limiter);
```

## Authentication and Security

### JWT Implementation

```javascript
import jwt from 'jsonwebtoken';

const generateToken = (user) => {
  return jwt.sign(
    { id: user.id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '24h' }
  );
};

const verifyToken = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ error: 'Invalid token' });
  }
};
```

## Performance Optimization

1. **Use Compression**: Reduce payload size
2. **Implement Pagination**: Limit data per request
3. **Database Indexing**: Optimize query performance
4. **Horizontal Scaling**: Use load balancers
5. **Microservices**: Split into smaller services

## Monitoring and Logging

```javascript
import winston from 'winston';

const logger = winston.createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' })
  ]
});

// Request logging middleware
app.use((req, res, next) => {
  logger.info({
    method: req.method,
    url: req.url,
    timestamp: new Date().toISOString()
  });
  next();
});
```

## Testing Your API

```javascript
// api.test.js
import request from 'supertest';
import app from './app';

describe('GET /api/users', () => {
  it('should return all users', async () => {
    const res = await request(app)
      .get('/api/users')
      .expect(200);
    
    expect(res.body).toHaveProperty('users');
    expect(Array.isArray(res.body.users)).toBe(true);
  });
});
```

## Conclusion

Building scalable REST APIs requires attention to design, performance, and security. By following these best practices and patterns, you can create APIs that handle growth gracefully and provide excellent developer experience.

Remember: good APIs are predictable, well-documented, and easy to use. Keep iterating and improving based on user feedback and monitoring data.